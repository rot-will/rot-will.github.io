

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="rot_will">
  <meta name="keywords" content="">
  
    <meta name="description" content="ptmlloc空间布局 chunk结构 12345678910111213141516171819202122struct malloc_chunk &amp;#123;  INTERNAL_SIZE_T      mchunk_prev_size;  INTERNAL_SIZE_T      mchunk_size;   &#x2F;* mchunk_prev_size 仅在前一个chunk被放入unsorted">
<meta property="og:type" content="article">
<meta property="og:title" content="堆基础">
<meta property="og:url" content="https://rot-will.github.io/page/heap/%E5%A0%86%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="rot&#39;s Blog">
<meta property="og:description" content="ptmlloc空间布局 chunk结构 12345678910111213141516171819202122struct malloc_chunk &amp;#123;  INTERNAL_SIZE_T      mchunk_prev_size;  INTERNAL_SIZE_T      mchunk_size;   &#x2F;* mchunk_prev_size 仅在前一个chunk被放入unsorted">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rot-will.github.io/img/blog_img/%E5%A0%86%E5%9F%BA%E7%A1%80/pwn-heap.jpg">
<meta property="article:published_time" content="2022-11-22T07:10:45.000Z">
<meta property="article:modified_time" content="2023-10-15T11:42:11.842Z">
<meta property="article:author" content="rot_will">
<meta property="article:tag" content="ctf">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://rot-will.github.io/img/blog_img/%E5%A0%86%E5%9F%BA%E7%A1%80/pwn-heap.jpg">
  
  
  
  <title>堆基础 - rot&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



    
        
        
        <link id="csscustom_image-light" rel="stylesheet" href="/css/image.css" />
        
          <link id="csscustom_image-dark" rel="stylesheet" href="/css/image-dark.css" />
        
    
        
        
        <link id="csscustom_salient-light" rel="stylesheet" href="/css/salient.css" />
        
          <link id="csscustom_salient-dark" rel="stylesheet" href="/css/salient-dark.css" />
        
    




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"rot-will.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Rot-will</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        

        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="堆基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        rot_will
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-22 15:10" pubdate>
          2022年11月22日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          46k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          383 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="heap"
        id="heading-4d4a9aa362b6ffe089fd2e992ccf4f5f" role="tab" data-toggle="collapse" href="#collapse-4d4a9aa362b6ffe089fd2e992ccf4f5f"
        aria-expanded="true"
      >
        heap
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-4d4a9aa362b6ffe089fd2e992ccf4f5f"
           role="tabpanel" aria-labelledby="heading-4d4a9aa362b6ffe089fd2e992ccf4f5f">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/page/heap/%E5%A0%86%E5%9F%BA%E7%A1%80/" title="堆基础"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">堆基础</span>
        </a>
      
    
      
      
        <a href="/page/heap/%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E4%B8%80/" title="攻击方法一"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">攻击方法一</span>
        </a>
      
    
      
      
        <a href="/page/heap/%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E4%BA%8C/" title="攻击方法二"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">攻击方法二</span>
        </a>
      
    
      
      
        <a href="/page/heap/IO%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E6%9E%90/" title="IO结构体分析"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">IO结构体分析</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">堆基础</h1>
            
              <p class="note note-light">
                
                  
                    本文最后更新于：2023年10月15日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1>ptmlloc空间布局</h1>
<h2 id="chunk结构">chunk结构</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      mchunk_prev_size;<br>  INTERNAL_SIZE_T      mchunk_size; <br>  <span class="hljs-comment">/* mchunk_prev_size 仅在前一个chunk被放入unsorted bin,small bin,large bin中使用</span><br><span class="hljs-comment">      存放前一个chunk的大小</span><br><span class="hljs-comment">     mchunk_size &amp; 1 标识着 前一个chunk是否被放入 unsorted bin,small bin,large bin中</span><br><span class="hljs-comment">     mchunk_size &amp; 2 标识着 当前chunk 是否由mmap分配</span><br><span class="hljs-comment">     mchunk_size &amp; 4 标识着 是否不属于主分配区 */</span><br>  <br>  <span class="hljs-comment">/* 32位程序chunk最小为0x10 ，chunk大小对于0x8进行对齐</span><br><span class="hljs-comment">    64位程序chunk最小为0x20 ，chunk大小对于0x10进行对齐 */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span>         <br>  <span class="hljs-comment">/* 上面四个字段是必须存在的 */</span><br><br>  <span class="hljs-comment">/* 下面两个字段仅在large bin中使用 */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span>  <br>  <span class="hljs-comment">/* fd/bk/fd_nextsize/bk_nextsize 仅在chunk被free之后使用</span><br><span class="hljs-comment">     当chunk正在被使用时，这四个字段用来储存当前chunk的数据 */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="/img/blog_img/%E5%A0%86%E5%9F%BA%E7%A1%80/pwn-heap.jpg" srcset="/img/loading.gif" lazyload alt="chunk结构" title="chunk结构"></p>
<pre><code class="hljs">下面以 glibc 2.31 为例分析
</code></pre>
<h2 id="构造">构造</h2>
<h3 id="libc-calloc">__libc_calloc</h3>
<pre><code class="hljs">calloc和malloc不同，calloc会初始化chunk的数据段，
  所以通过calloc创建的chunk中不会存放unsorted bin的地址
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * __libc_calloc (<span class="hljs-type">size_t</span> n, <span class="hljs-type">size_t</span> elem_size)<br>&#123;<br>  mstate av;<br>  mchunkptr oldtop, p;<br>  INTERNAL_SIZE_T sz, csz, oldtopsize;<br>  <span class="hljs-type">void</span> *mem;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clearsize;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nclears;<br>  INTERNAL_SIZE_T *d;<br>  <span class="hljs-type">ptrdiff_t</span> bytes;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (__builtin_mul_overflow (n, elem_size, &amp;bytes)))<br>    &#123;<span class="hljs-comment">// 先检测用户申请的chunk大小是否合理，并计算chunk size </span><br>       __set_errno (ENOMEM);<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  sz = bytes;<br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) =<br>    atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      mem = (*hook)(sz, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">memset</span> (mem, <span class="hljs-number">0</span>, sz);<br>      <span class="hljs-comment">// 当malloc_hook中存在值时替换__libc_calloc函数</span><br>    &#125;<br>  MAYBE_INIT_TCACHE (); <span class="hljs-comment">//检测并初始化tcache bin</span><br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>    av = &amp;main_arena;<br>  <span class="hljs-keyword">else</span><br>    arena_get (av, sz);<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">      当存在多线程时，获取可用分配区</span><br><span class="hljs-comment">      当仅有一个线程时，获取主分配区</span><br><span class="hljs-comment">     */</span><br> <br>  <span class="hljs-keyword">if</span> (av)<br>    &#123;<br>    <span class="hljs-comment">// 检测当前分配区top chunk后是否存在空闲区域，若存在，获取空闲空间的大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CLEARS</span><br>      oldtop = top (av);<br>      oldtopsize = chunksize (top (av));<br><span class="hljs-meta"># <span class="hljs-keyword">if</span> MORECORE_CLEARS &lt; 2</span><br>      <span class="hljs-keyword">if</span> (av == &amp;main_arena &amp;&amp;<br>	  oldtopsize &lt; mp_.sbrk_base + av-&gt;max_system_mem - (<span class="hljs-type">char</span> *) oldtop)<br>	oldtopsize = (mp_.sbrk_base + av-&gt;max_system_mem - (<span class="hljs-type">char</span> *) oldtop);<br>  <br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>	&#123;<br>	  heap_info *heap = heap_for_ptr (oldtop);<br>	  <span class="hljs-keyword">if</span> (oldtopsize &lt; (<span class="hljs-type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="hljs-type">char</span> *) oldtop)<br>	    oldtopsize = (<span class="hljs-type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="hljs-type">char</span> *) oldtop;<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      oldtop = <span class="hljs-number">0</span>;<br>      oldtopsize = <span class="hljs-number">0</span>;<br>    &#125;<br>  <span class="hljs-comment">// 先尝试使用_int_malloc获取chunk</span><br>  mem = _int_malloc (av, sz);<br>  assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||<br>          av == arena_for_chunk (mem2chunk (mem)));<br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">            检测chunk是否合法:</span><br><span class="hljs-comment">            chunk分配失败 mem==NULL</span><br><span class="hljs-comment">            chunk分配成功:</span><br><span class="hljs-comment">              mem 由mmap分配</span><br><span class="hljs-comment">              mem 由heap段分配</span><br><span class="hljs-comment">          */</span><br>  <span class="hljs-keyword">if</span> (!SINGLE_THREAD_P)<br>    &#123;<br>      <span class="hljs-comment">// 当存在多线程时,防止因为多线程导致chunk生成失败</span><br>      <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span> &amp;&amp; av != <span class="hljs-literal">NULL</span>)<br>	&#123;<br>    <br>	  LIBC_PROBE (memory_calloc_retry, <span class="hljs-number">1</span>, sz);<br>	  av = arena_get_retry (av, sz);<br>	  mem = _int_malloc (av, sz);<br>	&#125;<br>      <span class="hljs-keyword">if</span> (av != <span class="hljs-literal">NULL</span>)<br>	__libc_lock_unlock (av-&gt;mutex);<br>      <span class="hljs-comment">// 当存在分配区时，重新尝试构造chunk，并释放锁</span><br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  p = mem2chunk (mem);<br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))<br>    &#123;<br>      <span class="hljs-keyword">if</span> (__builtin_expect (perturb_byte, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">memset</span> (mem, <span class="hljs-number">0</span>, sz);<br>      <span class="hljs-keyword">return</span> mem;<br>      <span class="hljs-comment">// 当chunk由mmap分配时，如果perturb_byte存在，则初始化chunk的数据段</span><br>      <span class="hljs-comment">// 并返回chunk地址</span><br>    &#125;<br><br> <span class="hljs-comment">// 下面的代码是为了初始化chunk的数据段</span><br>  csz = chunksize (p);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CLEARS</span><br>  <span class="hljs-keyword">if</span> (perturb_byte == <span class="hljs-number">0</span> &amp;&amp; (p == oldtop &amp;&amp; csz &gt; oldtopsize))<br>    &#123;<br>      csz = oldtopsize;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  d = (INTERNAL_SIZE_T *) mem;<br>  clearsize = csz - SIZE_SZ;<br>  nclears = clearsize / <span class="hljs-keyword">sizeof</span> (INTERNAL_SIZE_T);<br>  assert (nclears &gt;= <span class="hljs-number">3</span>);<br>  <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">memset</span> (d, <span class="hljs-number">0</span>, clearsize);<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      *(d + <span class="hljs-number">0</span>) = <span class="hljs-number">0</span>;<br>      *(d + <span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;<br>      *(d + <span class="hljs-number">2</span>) = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">4</span>)<br>        &#123;<br>          *(d + <span class="hljs-number">3</span>) = <span class="hljs-number">0</span>;<br>          *(d + <span class="hljs-number">4</span>) = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">6</span>)<br>            &#123;<br>              *(d + <span class="hljs-number">5</span>) = <span class="hljs-number">0</span>;<br>              *(d + <span class="hljs-number">6</span>) = <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">8</span>)<br>                &#123;<br>                  *(d + <span class="hljs-number">7</span>) = <span class="hljs-number">0</span>;<br>                  *(d + <span class="hljs-number">8</span>) = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>  <span class="hljs-keyword">return</span> mem;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="realloc">realloc</h3>
<h4 id="libc-realloc">__libc_realloc</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__libc_realloc (<span class="hljs-type">void</span> *oldmem, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  INTERNAL_SIZE_T nb;<br>  <span class="hljs-type">void</span> *newp;<br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) =<br>    atomic_forced_read (__realloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// 检测当realloc_hook中存有函数地址时，替换realloc</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> REALLOC_ZERO_BYTES_FREES</span><br>  <span class="hljs-keyword">if</span> (bytes == <span class="hljs-number">0</span> &amp;&amp; oldmem != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-comment">// 但重构之后的size为0时，表示直接释放chunk</span><br>      __libc_free (oldmem); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-keyword">if</span> (oldmem == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> __libc_malloc (bytes);<br>    <span class="hljs-comment">// 当重构之前的chunk地址为0，则表示需要创建chunk</span><br><br><br>  <span class="hljs-type">const</span> mchunkptr oldp = mem2chunk (oldmem);<br>  <span class="hljs-type">const</span> INTERNAL_SIZE_T oldsize = chunksize (oldp);<br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (oldp))<br>    ar_ptr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      MAYBE_INIT_TCACHE ();<br>      ar_ptr = arena_for_chunk (oldp);<br>    &#125;<br>  <br>  <span class="hljs-keyword">if</span> ((__builtin_expect ((<span class="hljs-type">uintptr_t</span>) oldp &gt; (<span class="hljs-type">uintptr_t</span>) -oldsize, <span class="hljs-number">0</span>)<br>       || __builtin_expect (misaligned_chunk (oldp), <span class="hljs-number">0</span>))<br>      &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (oldp))<br>      malloc_printerr (<span class="hljs-string">&quot;realloc(): invalid pointer&quot;</span>);<br>      <span class="hljs-comment">//检测chunk地址是否合法</span><br><br>  <span class="hljs-keyword">if</span> (!checked_request2size (bytes, &amp;nb))<br>    &#123;<br>      <span class="hljs-comment">// 检测chunk的size是否合法并获取对齐后的size</span><br>      __set_errno (ENOMEM);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (oldp))<br>    &#123;<span class="hljs-comment">//当chunk由mmap分配时</span><br><br>      <span class="hljs-keyword">if</span> (DUMPED_MAIN_ARENA_CHUNK (oldp))<br>	&#123; <span class="hljs-comment">//其他储存区域 则新建chunk，不对原有chunk做操作</span><br>	  <span class="hljs-type">void</span> *newmem = __libc_malloc (bytes);<br>	  <span class="hljs-keyword">if</span> (newmem == <span class="hljs-number">0</span>)<br>	    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	  <span class="hljs-keyword">if</span> (bytes &gt; oldsize - SIZE_SZ)<br>	    bytes = oldsize - SIZE_SZ;<br>	  <span class="hljs-built_in">memcpy</span> (newmem, oldmem, bytes);<br>	  <span class="hljs-keyword">return</span> newmem;<br>	&#125;<br>      <span class="hljs-type">void</span> *newmem;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAVE_MREMAP</span><br>      newp = mremap_chunk (oldp, nb);<br>      <span class="hljs-comment">// 当存在mremap_chunk函数时，调用mremap_chunk函数对chunk进行重构操作</span><br>      <span class="hljs-comment">// mremap_chunk函数其实就是利用系统调用去重构chunk</span><br>      <span class="hljs-keyword">if</span> (newp)<br>        <span class="hljs-keyword">return</span> chunk2mem (newp);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">if</span> (oldsize - SIZE_SZ &gt;= nb)<br>        <span class="hljs-keyword">return</span> oldmem;  <span class="hljs-comment">// 因为时mmap分配的，如果经常进行创建，会影响程序执行效率，所以不缩小mmap分配的chunk</span><br><br>     <span class="hljs-comment">// 如果需要扩充chunk，则先使用malloc创建一个chunk</span><br>     <span class="hljs-comment">// 然后将原chunk的数据，复制到新的chunk中</span><br>     <span class="hljs-comment">// 然后将原chunk释放</span><br>      newmem = __libc_malloc (bytes);<br>      <span class="hljs-keyword">if</span> (newmem == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">memcpy</span> (newmem, oldmem, oldsize - <span class="hljs-number">2</span> * SIZE_SZ);<br>      munmap_chunk (oldp); <span class="hljs-comment">//使用mmap的方式释放chunk</span><br>      <span class="hljs-keyword">return</span> newmem;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>    &#123; <span class="hljs-comment">// 当仅有一个线程时，直接调用int_realloc重构chunk</span><br>      newp = _int_realloc (ar_ptr, oldp, oldsize, nb);<br>      assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||<br>	      ar_ptr == arena_for_chunk (mem2chunk (newp)));<br>      <span class="hljs-keyword">return</span> newp;<br>    &#125;<br>     <span class="hljs-comment">// 如果存在多个线程，则先设置线程锁，在重构之后再释放锁</span><br>  __libc_lock_lock (ar_ptr-&gt;mutex);<br>  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);<br>  __libc_lock_unlock (ar_ptr-&gt;mutex);<br>  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (newp)));<br>          <span class="hljs-comment">// 检测chunk是否合法</span><br><br>  <span class="hljs-keyword">if</span> (newp == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-comment">// 如果chunk重构失败，则尝试创建新的chunk</span><br>      <span class="hljs-comment">// 将原chunk的数据复制到新chunk中之后释放原chunk</span><br>      LIBC_PROBE (memory_realloc_retry, <span class="hljs-number">2</span>, bytes, oldmem);<br>      newp = __libc_malloc (bytes);<br>      <span class="hljs-keyword">if</span> (newp != <span class="hljs-literal">NULL</span>)<br>        &#123;<br><br>          <span class="hljs-built_in">memcpy</span> (newp, oldmem, oldsize - SIZE_SZ);<br>          _int_free (ar_ptr, oldp, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>  <span class="hljs-keyword">return</span> newp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="int-realloc">_int_realloc</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,<br>	     INTERNAL_SIZE_T nb)<br>&#123;<br>  mchunkptr        newp;<br>  INTERNAL_SIZE_T  newsize;<br>  <span class="hljs-type">void</span>*          newmem;<br>  mchunkptr        next;<br>  mchunkptr        remainder;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>    remainder_size;<br>  <span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (oldp) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>      || __builtin_expect (oldsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>    malloc_printerr (<span class="hljs-string">&quot;realloc(): invalid old size&quot;</span>);<br>    <span class="hljs-comment">// 对原chunk的size进行安全检测</span><br><br>  check_inuse_chunk (av, oldp);<br>    <span class="hljs-comment">// 对原chunk进行检测</span><br>  assert (!chunk_is_mmapped (oldp));<br>    <span class="hljs-comment">// 进入int_realloc函数的chunk肯定不由mmap创建的</span><br>  next = chunk_at_offset (oldp, oldsize);<br>  INTERNAL_SIZE_T nextsize = chunksize (next);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (next) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>      || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>    malloc_printerr (<span class="hljs-string">&quot;realloc(): invalid next size&quot;</span>);<br>    <span class="hljs-comment">// 检测下一个chunk的size是否合法</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (oldsize) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>    &#123;<br>      newp = oldp;<br>      newsize = oldsize;<br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (next == av-&gt;top &amp;&amp;<br>          (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (newsize = oldsize + nextsize) &gt;=<br>          (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>        &#123; <span class="hljs-comment">// 如果当前chunk的下一个chunk为top chunk</span><br>          <span class="hljs-comment">// 则直接分裂top chunk，来扩建当前chunk</span><br>          set_head_size (oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          av-&gt;top = chunk_at_offset (oldp, nb);<br>          set_head (av-&gt;top, (newsize - nb) | PREV_INUSE);<br>          check_inuse_chunk (av, oldp);<br>          <span class="hljs-keyword">return</span> chunk2mem (oldp);<br>        &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next != av-&gt;top &amp;&amp;<br>               !inuse (next) &amp;&amp;<br>               (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (newsize = oldsize + nextsize) &gt;=<br>               (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>        &#123;<br>          <span class="hljs-comment">// 如果下一个chunk不是top chunk，但下一个chunk为空闲chunk</span><br>          <span class="hljs-comment">// 且当前chunk的大小加上下一个chunk的大小比用户需要的大</span><br>          <span class="hljs-comment">// 则合并两个chunk，并将后一个chunk从原先的链表中分离出来</span><br>          newp = oldp;<br>          unlink_chunk (av, next);<br>        &#125;<br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-comment">// 如果当前chunk无法与下一个chunk合并</span><br>          <span class="hljs-comment">// 且下一个chunk不是top chunk</span><br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             使用malloc获取chunk</span><br><span class="hljs-comment">             如果获取到的chunk的地址为下一个chunk地址</span><br><span class="hljs-comment">                (下一个chunk可能在fast bin与tcache bin中)</span><br><span class="hljs-comment">             则先合并当前chunk与下一个chunk</span><br><span class="hljs-comment">             如果与当前chunk不相邻，则释放当前chunk</span><br><span class="hljs-comment">              将新获取的chunk返回给用户 </span><br><span class="hljs-comment">          */</span><br>          newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);<br>          <span class="hljs-keyword">if</span> (newmem == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>          newp = mem2chunk (newmem);<br>          newsize = chunksize (newp);<br>          <span class="hljs-keyword">if</span> (newp == next)<br>            &#123;<br>              newsize += oldsize;<br>              newp = oldp;<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>	      <span class="hljs-built_in">memcpy</span> (newmem, chunk2mem (oldp), oldsize - SIZE_SZ);<br>              _int_free (av, oldp, <span class="hljs-number">1</span>);<br>              check_inuse_chunk (av, newp);<br>              <span class="hljs-keyword">return</span> chunk2mem (newp);<br>            &#125;<br>        &#125;<br>    &#125;<br>  assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (newsize) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br>    <span class="hljs-comment">// 程序执行到这里，新chunk的大小必定大于原chunk</span><br><br>  <span class="hljs-comment">/* 尝试分裂当前chunk，尝试将多余的空间组成一个新的chunk，并释放 */</span><br>  remainder_size = newsize - nb;<br>  <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>    &#123;<br>      set_head_size (newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>      set_inuse_bit_at_offset (newp, newsize);<br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      remainder = chunk_at_offset (newp, nb);<br>      set_head_size (newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>      set_head (remainder, remainder_size | PREV_INUSE |<br>                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>      set_inuse_bit_at_offset (remainder, remainder_size);<br>      _int_free (av, remainder, <span class="hljs-number">1</span>);<br>    &#125;<br>  check_inuse_chunk (av, newp);<br>  <span class="hljs-keyword">return</span> chunk2mem (newp);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="malloc">malloc</h3>
<h4 id="libc-malloc">__libc_malloc</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br><br>  <span class="hljs-keyword">_Static_assert</span> (PTRDIFF_MAX &lt;= SIZE_MAX / <span class="hljs-number">2</span>,<br>                  <span class="hljs-string">&quot;PTRDIFF_MAX is not more than half of SIZE_MAX&quot;</span>);<br>   <span class="hljs-comment">/* 当地址之间的差距不大于 size_t类型的数据所储存的最大数/2</span><br><span class="hljs-comment">    则报错 */</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>  <span class="hljs-comment">/* 检测 malloc_hook 中是否存有函数地址，</span><br><span class="hljs-comment">      如果有则调用指向的函数 </span><br><span class="hljs-comment">     在第一次调用 __libc_malloc 时,</span><br><span class="hljs-comment">      __malloc_hook中储存了malloc_hook_ini函数地址</span><br><span class="hljs-comment">      用于分配区初始化</span><br><span class="hljs-comment">      */</span><br>    <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-comment">/* tcache从glibc2.26开始被使用 */</span><br><br>  <span class="hljs-type">size_t</span> tbytes;<br>  <span class="hljs-keyword">if</span> (!checked_request2size (bytes, &amp;tbytes))<br>    &#123; <br>      __set_errno (ENOMEM);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>      <span class="hljs-comment">/* 如果用户申请的chunk超过了可索引的地址范围</span><br><span class="hljs-comment">          就返回NULL 表示分配失败 */</span><br>    &#125;<br>  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (tbytes);<br>   <span class="hljs-comment">/* 获取chunk的size对应的tcache bin的编号 */</span><br>  MAYBE_INIT_TCACHE ();<br>   <span class="hljs-comment">/* 检测tcache bins是否被初始化过，</span><br><span class="hljs-comment">        如果还未初始化tcache bins,</span><br><span class="hljs-comment">        则调用tcache_init函数对tcache bins进行初始化操作*/</span><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins<br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">/* 当存在对应的tcache bin，且tcache bin中存在chunk</span><br><span class="hljs-comment">         则直接将tcache bin中的chunk返回给用户 */</span><br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br>  <span class="hljs-comment">/* 当使用了tcache bin时，先从tcache bin中获取chunk */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>    &#123;  <span class="hljs-comment">/* 当程序仅有一个线程时，使用_int_malloc申请chunk</span><br><span class="hljs-comment">          并对返回的chunk地址进行验证(创建失败 或 由mmap分配 或 由主分配区分配) */</span><br>      victim = _int_malloc (&amp;main_arena, bytes);<br>      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>	      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));<br>      <span class="hljs-keyword">return</span> victim;<br>    &#125;<br><br>  arena_get (ar_ptr, bytes);<br>  <span class="hljs-comment">/* 获取当前线程分配区，当当前分配区为空时，尝试使用其他分配区 */</span><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <br>  <span class="hljs-comment">/* 利用_int_malloc申请chunk */</span><br><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>      <span class="hljs-comment">/* 当无法使用当前线程分配区申请chunk时，使用其他的分配区申请chunk */</span><br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br>  <br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br>	<br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="malloc-hook-ini">malloc_hook_ini</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">malloc_hook_ini</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> sz, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *caller)</span><br>&#123;<br>  __malloc_hook = <span class="hljs-literal">NULL</span>;<br>  ptmalloc_init (); <span class="hljs-comment">/* 初始化主分配区,初始化分配区中的bin*/</span><br>  <span class="hljs-keyword">return</span> __libc_malloc (sz);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="int-malloc">_int_malloc</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;<br>  mbinptr bin;<br>  mchunkptr victim;<br>  INTERNAL_SIZE_T size;<br>  <span class="hljs-type">int</span> victim_index;<br>  mchunkptr remainder;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;<br>  mchunkptr fwd;<br>  mchunkptr bck;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-type">size_t</span> tcache_unsorted_count;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>   <span class="hljs-comment">/* 检测申请的chunk，因为申请chunk不只有malloc，还有calloc,realloc，</span><br><span class="hljs-comment">      所以在_int_malloc中再检测一次请求的大小是否合法 */</span><br><br>  <span class="hljs-keyword">if</span> (!checked_request2size (bytes, &amp;nb))<br>    &#123;<br>      __set_errno (ENOMEM);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-comment">/* 当av==NULL时，表示没有分配区可以分配chunk了，所以需要调用sysmalloc从系统分配空间 */</span><br><br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>	alloc_perturb (p, bytes); <span class="hljs-comment">/* 初始化chunk data */</span><br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REMOVE_FB(fb, victim, pp)	\</span><br><span class="hljs-meta">  do							\</span><br><span class="hljs-meta">    &#123;							\</span><br><span class="hljs-meta">      victim = pp;					\</span><br><span class="hljs-meta">      <span class="hljs-keyword">if</span> (victim == NULL)				\</span><br><span class="hljs-meta">	break;						\</span><br><span class="hljs-meta">    &#125;							\</span><br><span class="hljs-meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="hljs-meta">	 != victim);					<span class="hljs-comment">/* 在存在多个线程的情况下，用于取出当前bin中第一个chunk */</span></span><br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>    &#123;<br>      idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp;<br>      victim = *fb;<br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>)<br>	&#123;<br>	  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>	    *fb = victim-&gt;fd;<br>	  <span class="hljs-keyword">else</span><br>	    REMOVE_FB (fb, pp, victim);<br>      <span class="hljs-comment">/* 因为在符合用户申请的chunk大小的fast bin中，存在空闲chunk，</span><br><span class="hljs-comment">          所以直接将bin中第一个chunk返回给用户 */</span><br><br>	  <span class="hljs-keyword">if</span> (__glibc_likely (victim != <span class="hljs-literal">NULL</span>))<br>	    &#123;<br>	      <span class="hljs-type">size_t</span> victim_idx = fastbin_index (chunksize (victim));<br>	      <span class="hljs-keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="hljs-number">0</span>))<br>		malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>);<br>          <span class="hljs-comment">/* 检测bin中的chunk是否被恶意修改过 */</span><br><br>	      check_remalloced_chunk (av, victim, nb);<br>          <span class="hljs-comment">/* 对chunk进行全面的安全检测 */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE </span><br>      <span class="hljs-comment">/* 因为从fast bin中获取到的chunk大小与用户申请的chunk相同</span><br><span class="hljs-comment">          所以直接通过用户申请chunk大小，获取对应的tcache bin编号</span><br><span class="hljs-comment">          将当前fast bin中所有chunk放入tcache bin中，直到tcache bin被填满</span><br><span class="hljs-comment">          如果fast bin中还有chunk，就将其返回给用户 */</span><br><br>      <span class="hljs-comment">/*因为这个版本fast bin的检测较多，fast bin attack 不好利用，</span><br><span class="hljs-comment">         可以在fast bin的开头放一个正常的chunk，修改其fd为内存中任意地址，</span><br><span class="hljs-comment">          然后申请一个相应大小的chunk，使正常chunk与我们想要的地址都放入tcache bin中</span><br><span class="hljs-comment">          因为tcache bin的检测较少，只要允许申请足够数量的chunk，</span><br><span class="hljs-comment">          就可以在内存中任意位置创建一个chunk</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         或者在tcache bin中只剩一个空位时，将fast bin中开头的正常的chunk放入tcache bin中</span><br><span class="hljs-comment">          这时因为tcache bin被填满了，这时就会在内存中任意地址创建一个chunk(需要程序使用calloc) */</span><br><br>	      <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>	      <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>		&#123; <br>		  mchunkptr tc_victim;<br>		  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>			 &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>)<br>		    &#123;<br>		      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>			  <br>			*fb = tc_victim-&gt;fd;<br>		      <span class="hljs-keyword">else</span><br>			&#123;<br>			  REMOVE_FB (fb, pp, tc_victim);<br>			  <span class="hljs-keyword">if</span> (__glibc_unlikely (tc_victim == <span class="hljs-literal">NULL</span>))<br>			    <span class="hljs-keyword">break</span>;<br>			&#125;<br>		      tcache_put (tc_victim, tc_idx);<br>		    &#125;<br>		&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	      <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>	      alloc_perturb (p, bytes);<br>	      <span class="hljs-keyword">return</span> p;<br>	    &#125;<br>	&#125;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>    &#123; <span class="hljs-comment">/* 当用户申请的chunk大小，符合small bin的范围 */</span><br><br>      idx = smallbin_index (nb);<br>      bin = bin_at (av, idx);<br>      <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>        &#123; <span class="hljs-comment">/* 判断对应的small bin中是否存在chunk */</span><br>          bck = victim-&gt;bk;<br>	  <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>	    malloc_printerr (<span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);<br>          <span class="hljs-comment">/* 检测双链表结构是否被破坏 */</span><br><br>          set_inuse_bit_at_offset (victim, nb);<br>          bin-&gt;bk = bck;<br>          bck-&gt;fd = bin;<br>          <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>	    set_non_main_arena (victim);<br>          check_malloced_chunk (av, victim, nb);<br>          <span class="hljs-comment">/* 将chunk从small bin中取出 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>    <span class="hljs-comment">/* 当对应的tcache bin还没有填满，循环遍历small bin，</span><br><span class="hljs-comment">        直到tcache bin被填满，将剩余的第一个chunk返回给用户 */</span><br>    <br>    <span class="hljs-comment">/* 因为small bin中存在一个双链表检测，</span><br><span class="hljs-comment">         所以想要通过small bin在内存中某个位置创建chunk就比较困难</span><br><span class="hljs-comment">         不过可以通过tcache bin，与上面fast bin的思路相同*/</span><br><br>    <span class="hljs-comment">/* 因为这里仅对当前chunk进行链表检测，所以如果我们构造的地址在第三个或之后</span><br><span class="hljs-comment">      则可以绕过检测，直接在任意地址处放置chunk */</span><br><br>	  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>	  <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>	    &#123;<br>	      mchunkptr tc_victim;<br>	      <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>		     &amp;&amp; (tc_victim = last (bin)) != bin)<br>		&#123;<br>		  <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)<br>		    &#123;<br>		      bck = tc_victim-&gt;bk;<br>		      set_inuse_bit_at_offset (tc_victim, nb);<br>		      <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>			set_non_main_arena (tc_victim);<br>		      bin-&gt;bk = bck;<br>		      bck-&gt;fd = bin;<br>		      tcache_put (tc_victim, tc_idx);<br>	            &#125;<br>		&#125;<br>	    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      idx = largebin_index (nb);<br>      <span class="hljs-comment">/* 获取用户申请的大小对应得到large bin编号 */</span><br>      <span class="hljs-keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))<br>        malloc_consolidate (av); <br>      <span class="hljs-comment">/* 合并fast bin中的chunk，并将合并后的chunk放入对应的small bin或large bin中 */</span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  INTERNAL_SIZE_T tcache_nb = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>  <span class="hljs-comment">/* 当用户申请的大小对应的tcache bin中存在chunk</span><br><span class="hljs-comment">      则做好准备，在大循环中尝试从tcache bin中获取chunk */</span><br>  <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>    tcache_nb = nb;<br>  <span class="hljs-type">int</span> return_cached = <span class="hljs-number">0</span>;<br>  tcache_unsorted_count = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-keyword">for</span> (;; )<br>    &#123; <span class="hljs-comment">/* 进入大循环 */</span><br>      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123; <span class="hljs-comment">/* 循环遍历unsorted bin中的chunk，将其中的chunk放入对应的bin中</span><br><span class="hljs-comment">              当符合用户申请的条件时，尝试分裂后返回给用户 */</span><br>          bck = victim-&gt;bk;<br>          size = chunksize (victim);<br>          mchunkptr next = chunk_at_offset (victim, size);<br>          <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt;= <span class="hljs-number">2</span> * SIZE_SZ)<br>              || __glibc_unlikely (size &gt; av-&gt;system_mem))<br>            malloc_printerr (<span class="hljs-string">&quot;malloc(): invalid size (unsorted)&quot;</span>);<br>          <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="hljs-number">2</span> * SIZE_SZ)<br>              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))<br>            malloc_printerr (<span class="hljs-string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);<br>          <span class="hljs-keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))<br>            malloc_printerr (<span class="hljs-string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);<br>          <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)<br>              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))<br>            malloc_printerr (<span class="hljs-string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);<br>          <span class="hljs-keyword">if</span> (__glibc_unlikely (prev_inuse (next)))<br>            malloc_printerr (<span class="hljs-string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);<br>           <span class="hljs-comment">/* 进行安全检测</span><br><span class="hljs-comment">              1. 检测当前chunk大小是否合法</span><br><span class="hljs-comment">              2. 检测与当前chunk相邻的后一个chunk的大小是否合法</span><br><span class="hljs-comment">              3. 检测当前chunk的大小或相邻的后一个chunk的prev_size段是否被修改</span><br><span class="hljs-comment">              4. 检测双链表结构是否被破坏(防止unsorted bin的指针被修改)</span><br><span class="hljs-comment">              5. 检测相邻的后一个chunk的inuse位是否为0(如果为1则表示后面的chunk被修改了)</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>            &#123; <span class="hljs-comment">/* </span><br><span class="hljs-comment">                 1. 用户申请的chunk大小符合small bin </span><br><span class="hljs-comment">                 2. unsorted bin中只有一个chunk时</span><br><span class="hljs-comment">                 3. 当前的chunk是由之前的chunk分裂后生成的</span><br><span class="hljs-comment">                 4. 当前的chunk分裂出用户申请的chunk后，还可以生成至少一个chunk</span><br><span class="hljs-comment">                 */</span><br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                  <span class="hljs-comment">/* 当分裂后剩余的chunk 符合large bin的范围时，</span><br><span class="hljs-comment">                      为将chunk放入large bin中做好准备 */</span><br>                &#125;<br>              set_head (victim, nb | PREV_INUSE |<br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>              set_head (remainder, remainder_size | PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-comment">/* 设置分裂后剩余的chunk的头部，并对返回给用户的chunk进行安全检测与data初始化操作 */</span><br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>          <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>            malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>            <span class="hljs-comment">/* 再次检测双链表完整性，防止unsorted bin中的chunk被修改 */</span><br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av); <br>            <span class="hljs-comment">/* 将当前chunk从unsorted bin中取出</span><br><span class="hljs-comment">                将其放入相应的bin中 */</span><br><br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123; <span class="hljs-comment">/* 当chunk的大小符合用户申请的大小时，</span><br><span class="hljs-comment">                  如果对应的tcache bin中没有填满，则先将chunk放入tcache bin中</span><br><span class="hljs-comment">                  如果填满了，就设置好chunk的头部，将其返回给用户 */</span><br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>		set_non_main_arena (victim);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>	      <span class="hljs-keyword">if</span> (tcache_nb<br>		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>		&#123;<br>		  tcache_put (victim, tc_idx);<br>		  return_cached = <span class="hljs-number">1</span>; <span class="hljs-comment">/* 设置状态变量，在遍历unsorted bin之后，从tcache bin中获取chunk</span><br><span class="hljs-comment">                              防止资源浪费 */</span><br>		  <span class="hljs-keyword">continue</span>;<br>		&#125;<br>	      <span class="hljs-keyword">else</span><br>		&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>		&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            &#125;<br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>            &#123; <span class="hljs-comment">/* 当chunk符合small bin的范围时，准备好将其放入small bin </span><br><span class="hljs-comment">                  获取对应的small bin编号，并获取small bin中结尾的chunk，</span><br><span class="hljs-comment">                  用于将当前chunk添加进small bin */</span><br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              <span class="hljs-comment">/* 当chunk符合large bin的范围时，准备好将其放入large bin</span><br><span class="hljs-comment">                  获取对应的large bin编号，获取对应bin的最后一个chunk*/</span><br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123; <span class="hljs-comment">/* 当bin中存在成员时 */</span><br>                  size |= PREV_INUSE;<br>                  assert (chunk_main_arena (bck-&gt;bk)); <br>                    <span class="hljs-comment">/* 当chunk不是通过主分配区分配则中断程序*/</span><br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size)<br>		      &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (bck-&gt;bk))<br>                    &#123; <span class="hljs-comment">/* 因为bck-&gt;bk 指向的是第一个chunk，</span><br><span class="hljs-comment">                          在large bin中第一个chunk就是当前bin中最小的chunk</span><br><span class="hljs-comment">                          如果当前chunk的大小比当前bin中最小的chunk还小</span><br><span class="hljs-comment">                          就准备将当前chunk插入large bin的开头，</span><br><span class="hljs-comment">                          并将其加入size_bin中 */</span><br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                  <span class="hljs-comment">/* 这里没有检测size_bin是否完整，</span><br><span class="hljs-comment">                      所以只要原先在large bin中存在一个较大chunk，</span><br><span class="hljs-comment">                      并且设置chunk中bk_nextsize字段为内存中的地址，</span><br><span class="hljs-comment">                      然后再从unsorted bin向large bin放入一个大小较小的chunk</span><br><span class="hljs-comment">                      就会向 原先指定的内存中的地址+0x20位置处 写入一个堆块地址 </span><br><span class="hljs-comment">                      这种利用方法叫做large bin attack*/</span><br><br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert (chunk_main_arena (fwd));<br>                      <span class="hljs-comment">/* 限制chunk必须属于主分配区，这里是防止bin被修改 */</span> <br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; chunksize_nomask (fwd))<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>			  assert (chunk_main_arena (fwd));<br>                          <span class="hljs-comment">/* 利用size_bin获取large bin中第一个比当前chunk小的成员 </span><br><span class="hljs-comment">                            这样就可以找到一个 a&lt;= ?? &lt;b 的位置*/</span><br>                        &#125;<br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size<br>			  == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (fwd))  <br>        <span class="hljs-comment">/*如果当前chunk与找到的size_bin的第一个成员大小相同，</span><br><span class="hljs-comment">            则将当前chunk插入到找到的size_bin节点在large bin中的位置的前面*/</span><br><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          <span class="hljs-comment">/* 这种情况就是 a&lt; ?? &lt; b</span><br><span class="hljs-comment">                            所以在 size_bin中创建一个节点，在找到的节点后面</span><br><span class="hljs-comment">                            并将当前chunk插入到找到的size_bin节点在large bin中位置的后面*/</span><br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<br>                            malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);<br>                            <span class="hljs-comment">/* 检测size_bin完整性 */</span><br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                      <span class="hljs-keyword">if</span> (bck-&gt;fd != fwd)<br>                        malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>                <span class="hljs-comment">/* 当bin中不存在成员时，直接设置好chunk所属的size_bin，</span><br><span class="hljs-comment">                  size_bin属于当前large bin，用来快速找到当前bin中下一个较大的chunk*/</span><br>            &#125;<br>          mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br>          <span class="hljs-comment">/* 这里是真正将chunk放入small bin或large bin */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>      ++tcache_unsorted_count;<br>      <span class="hljs-keyword">if</span> (return_cached<br>	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="hljs-number">0</span><br>	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<br>	&#123; <span class="hljs-comment">/* 如果在执行上面的代码时 将unsorted bin中的chunk放入了tcache bin</span><br><span class="hljs-comment">        且tcache 设置了遍历unsorted bin获取chunk的阈值</span><br><span class="hljs-comment">        遍历unsorted bin中的chunk数量已经超过阈值，</span><br><span class="hljs-comment">        则直接将刚刚放入tcache bin中的chunk返回给用户*/</span><br>	  <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 限制循环次数 防止死循环*/</span><br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>      <span class="hljs-keyword">if</span> (return_cached)<br>	&#123; <span class="hljs-comment">/* 如果上面的代码 从unsorted bin中取出chunk，</span><br><span class="hljs-comment">        并将其放入tcache bin中，则从tcache bin中取出chunk并返回给用户*/</span><br>	  <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>        &#123; <span class="hljs-comment">/* 当用户申请的chunk大小符合large bin的范围时 */</span><br><br>          bin = bin_at (av, idx);<br>          <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin<br>	      &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (victim)<br>	        &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>            &#123; <span class="hljs-comment">/* 在大循环执行获取的用户申请的chunk的大小对应的large bin的编号在这里用上了</span><br><span class="hljs-comment">                   在链表中 bin本身的fd指针指向的是bin中最后一个成员</span><br><span class="hljs-comment">                                    bk指针指向的是bin中第一个成员</span><br><span class="hljs-comment">                   所以这里是确认找到的bin中存在 符合用户申请的大小 的chunk</span><br><span class="hljs-comment">                  (因为large bins中每个bin都不是只能储存一种大小的chunk</span><br><span class="hljs-comment">                     所以在 符合条件的bin 中存在比 申请的大小大的chunk) */</span><br><br>              victim = victim-&gt;bk_nextsize; <br>              <br>              <span class="hljs-comment">/*从前面将unsorted bin中的chunk放入large bin的代码可以看出</span><br><span class="hljs-comment">                  large bin中最后一个节点 也是对应的 size_bin的最后一个节点 </span><br><span class="hljs-comment">                因为victim是最大的，所以victim-&gt;bk_nextsize就是size_bin中最小的chunk */</span><br>              <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>                victim = victim-&gt;bk_nextsize;<br>                <span class="hljs-comment">/* 搜索当前bin，找到第一个符合用户申请大小的chunk */</span><br><br>              <span class="hljs-keyword">if</span> (victim != last (bin)<br>		  &amp;&amp; chunksize_nomask (victim)<br>		    == chunksize_nomask (victim-&gt;fd))<br>                victim = victim-&gt;fd;<br>              <span class="hljs-comment">/* 当搜索到的size_bin的节点不是当前bin中第一个成员</span><br><span class="hljs-comment">                  且在当前bin中与找到的节点大小相同的chunk不止一个</span><br><span class="hljs-comment">                   将 其他的大小与找到的节点相同的chunk 返回给用户</span><br><span class="hljs-comment">                  为防止频繁改动size_bin，非必要情况下一般不使用size_bin的节点创建chunk*/</span><br><br>              remainder_size = size - nb;<br>              unlink_chunk (av, victim); <br>                <span class="hljs-comment">/* 执行unlink</span><br><span class="hljs-comment">                    先将要返回给用户的chunk从bin中分离出来 */</span><br>              <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>                &#123; <span class="hljs-comment">/* 如果将找到的chunk分裂之后无法再生成一个chunk</span><br><span class="hljs-comment">                      则直接将找到的chunk返回给用户 */</span><br><br>                  set_inuse_bit_at_offset (victim, size);<br>                  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>		    set_non_main_arena (victim);<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  <span class="hljs-comment">/* 将找到的chunk分裂，并将剩余空间设置为一个新的chunk放入unsorted bin中 */</span><br>                  remainder = chunk_at_offset (victim, nb);<br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>		  <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>		    malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);<br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<br>                  <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                      remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                  set_head (victim, nb | PREV_INUSE |<br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                  set_head (remainder, remainder_size | PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<br>                &#125;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-comment">/* 对chunk进行检测，并进行初始化操作之后返回给用户 */</span><br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>      ++idx;<br>      bin = bin_at (av, idx);<br>      block = idx2block (idx);<br>      <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<br>      bit = idx2bit (idx);<br>      <span class="hljs-comment">/* 在上面的代码中搜索了所有刚好符合 用户申请大小条件的bin</span><br><span class="hljs-comment">          这里先获取 符合用户申请大小条件的 一组 bin 与 bin 在这一组中的索引</span><br><span class="hljs-comment">          在下面的代码会搜索所有bin，除非找不到符合条件chunk*/</span><br>      <span class="hljs-keyword">for</span> (;; )<br>        &#123;<br>          <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>            &#123;<br>              <span class="hljs-keyword">do</span><br>                &#123;<br>                  <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE)<br>                    <span class="hljs-keyword">goto</span> use_top;<br>                    <span class="hljs-comment">/* 先尝试搜索一组有成员的bin，如果找不到就使用top chunk分裂获取*/</span><br>                &#125;<br>              <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br>              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>              bit = <span class="hljs-number">1</span>; <br>            &#125;<br>          <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>            &#123;<br>              <span class="hljs-comment">/* 在上面的do...while循环中已经找到一组肯定存在成员的bin</span><br><span class="hljs-comment">                现在是要精确找到存在成员的bin </span><br><span class="hljs-comment">                 bit==0 就表示程序流被控制了*/</span><br>              bin = next_bin (bin);<br>              bit &lt;&lt;= <span class="hljs-number">1</span>;<br>              assert (bit != <span class="hljs-number">0</span>);<br>            &#125;<br>          victim = last (bin);<br>          <span class="hljs-keyword">if</span> (victim == bin)<br>            &#123; <span class="hljs-comment">/* 如果找到的bin中实际上没有chunk</span><br><span class="hljs-comment">                  则表示 在获取 binmap的值没有更新</span><br><span class="hljs-comment">                  这里更新一下map，并获取下一个bin，然后进行下一次循环 */</span><br>              av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit;<br>              bin = next_bin (bin);<br>              bit &lt;&lt;= <span class="hljs-number">1</span>;<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              size = chunksize (victim);<br>              assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br>              <span class="hljs-comment">/* 如果这里找到的chunk的大小小于用户申请的大小，则表示chunk被恶意修改了 */</span><br>              remainder_size = size - nb;<br>              unlink_chunk (av, victim);<br>               <span class="hljs-comment">/* 将找到的chunk从对应的bin中分离出来 */</span><br>              <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>                &#123;<br>                  set_inuse_bit_at_offset (victim, size);<br>                  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>		    set_non_main_arena (victim);<br>                    <span class="hljs-comment">/* 如果分裂后剩余空间无法生成一个完整的chunk，</span><br><span class="hljs-comment">                        则直接将整个chunk返回给用户 */</span><br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  <span class="hljs-comment">/* 将chunk分裂，并将分裂后剩余空间设置为一个新的chunk放入unsorted bin中*/</span><br>                  remainder = chunk_at_offset (victim, nb);<br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>		  <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>		    malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);<br>                    <span class="hljs-comment">/* 检测双链表完整性 */</span><br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<br>                  <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                    av-&gt;last_remainder = remainder;<br>                  <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                      remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                      <span class="hljs-comment">/* 如果分裂后剩余空间符合large bin的条件，则初始化fd_nextsize,bk_nextsize */</span><br>                    &#125;<br>                  set_head (victim, nb | PREV_INUSE |<br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                  set_head (remainder, remainder_size | PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<br>                &#125;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-comment">/* 设置好chunk的标志，并进行检测与初始化data的操作，然后将chunk返回给用户 */</span><br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    use_top:<br>      <span class="hljs-comment">/* 当上面的操作都无法获取chunk，则尝试通过分裂top chunk获取chunk */</span><br>      victim = av-&gt;top;<br>      size = chunksize (victim);<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))<br>        malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted top size&quot;</span>);<br>        <span class="hljs-comment">/* 检测top chunk的大小是否过大，这种情况一般是top chunk的size被恶意修改了 */</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>        &#123; <span class="hljs-comment">/* 当top chunk分裂出用户申请的chunk之后还可以生成一个完整的chunk时 */</span><br>          remainder_size = size - nb;<br>          remainder = chunk_at_offset (victim, nb);<br>          av-&gt;top = remainder;<br>          set_head (victim, nb | PREV_INUSE |<br>                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          set_head (remainder, remainder_size | PREV_INUSE);<br>          check_malloced_chunk (av, victim, nb);<br>          <span class="hljs-type">void</span> *p = chunk2mem (victim); <span class="hljs-comment">/* 获取chunk的data字段地址*/</span><br>          alloc_perturb (p, bytes);<br>          <span class="hljs-comment">/* 从top chunk分裂出chunk之后，为chunk设置头部，并进行安全检测与初始化data操作</span><br><span class="hljs-comment">             然后将chunk返回给用户 */</span><br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))<br>        &#123;<br>          malloc_consolidate (av);<br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>            idx = smallbin_index (nb);<br>          <span class="hljs-keyword">else</span><br>            idx = largebin_index (nb);<br>          <span class="hljs-comment">/* 当fast bin中存在chunk时，合并fast bin中的chunk，并将合并后的chunk放入对应的bin中</span><br><span class="hljs-comment">              先获取符合用户申请的chunk的bin的编号，然后进入下一次循环 */</span><br>        &#125;<br>      <span class="hljs-keyword">else</span><br>        &#123; <span class="hljs-comment">/* 这种情况就是top chunk没有多余空间用来生成chunk</span><br><span class="hljs-comment">              且bin中也没有符合条件的chunk</span><br><span class="hljs-comment">              尝试使用 sysmalloc 从内存中申请空间</span><br><span class="hljs-comment">               如果原因处在top chunk过小，这个函数就会扩展top chunk */</span><br>          <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>          <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-comment">/* 将获取的chunk初始化后返回给用户*/</span><br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="malloc-consolidate">malloc_consolidate</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_consolidate</span><span class="hljs-params">(mstate av)</span><br>&#123;<br>  mfastbinptr*    fb;<br>  mfastbinptr*    maxfb;<br>  mchunkptr       p;<br>  mchunkptr       nextp;<br>  mchunkptr       unsorted_bin;<br>  mchunkptr       first_unsorted;<br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-type">int</span>             nextinuse;<br>  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="hljs-literal">false</span>);<br>  unsorted_bin = unsorted_chunks(av);<br>  maxfb = &amp;fastbin (av, NFASTBINS - <span class="hljs-number">1</span>);<br>  fb = &amp;fastbin (av, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-comment">/* 遍历所有fast bin */</span><br>    p = atomic_exchange_acq (fb, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* 获取bin中第一个成员*/</span><br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">do</span> &#123;<br>	  &#123;  <span class="hljs-comment">/* 如果bin中没有成员则跳过 */</span><br>	    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index (chunksize (p));<br>	    <span class="hljs-keyword">if</span> ((&amp;fastbin (av, idx)) != fb)<br>	      malloc_printerr (<span class="hljs-string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);<br>        <span class="hljs-comment">/* 如果获取到的chunk的size不属于当前bin，则表示chunk被修改过了 */</span><br>	  &#125;<br>	  check_inuse_chunk(av, p); <span class="hljs-comment">/* 检测当前chunk及其附近的chunk的大小和inuse位是否合法 */</span><br>	  nextp = p-&gt;fd;  <span class="hljs-comment">/* 获取fast bin中下一个成员，为下一次循环做准备 */</span><br>	  size = chunksize (p);<br>	  nextchunk = chunk_at_offset(p, size);<br>	  nextsize = chunksize(nextchunk);<br>	  <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>      <span class="hljs-comment">/* 当当前chunk的inuse位为0时，表示前一个chunk属于空闲状态</span><br><span class="hljs-comment">          合并两个chunk */</span><br>	    prevsize = prev_size (p);<br>	    size += prevsize;<br>	    p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>      <span class="hljs-comment">/* 如果当前chunk的prev_size字段不等于 前一个chunk的size字段，则表示当前chunk被恶意     修改过了*/</span><br>	    <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>	      malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);<br>	    unlink_chunk (av, p);<br>	  &#125;<br>	  <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>      <span class="hljs-comment">/* 确保后一个chunk不是top chunk，如果是就直接与top chunk合并  */</span><br>	    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br>	    <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>	      size += nextsize;<br>	      unlink_chunk (av, nextchunk);<br>        <span class="hljs-comment">/* 如果后一个chunk当前为空闲状态，则将其从所在bin中取出 */</span><br>	    &#125; <span class="hljs-keyword">else</span><br>	      clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br>	    first_unsorted = unsorted_bin-&gt;fd;<br>	    unsorted_bin-&gt;fd = p;<br>	    first_unsorted-&gt;bk = p;<br>	    <span class="hljs-keyword">if</span> (!in_smallbin_range (size)) &#123;<br>	      p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>	      p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>	    &#125;<br>	    set_head(p, size | PREV_INUSE);<br>	    p-&gt;bk = unsorted_bin;<br>	    p-&gt;fd = first_unsorted;<br>	    set_foot(p, size);<br>      <span class="hljs-comment">/* 设置好合并后的chunk头部，并将合并后的chunk放入unsorted bin中 */</span><br>	  &#125;<br>	  <span class="hljs-keyword">else</span> &#123;<br>	    size += nextsize;<br>	    set_head(p, size | PREV_INUSE);<br>	    av-&gt;top = p;<br>	  &#125;<br>      &#125; <span class="hljs-keyword">while</span> ( (p = nextp) != <span class="hljs-number">0</span>);<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="sysmalloc">sysmalloc</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">sysmalloc</span> <span class="hljs-params">(INTERNAL_SIZE_T nb, mstate av)</span><br>&#123;<br>  mchunkptr old_top;<br>  INTERNAL_SIZE_T old_size;<br>  <span class="hljs-type">char</span> *old_end;<br>  <span class="hljs-type">long</span> size;<br>  <span class="hljs-type">char</span> *brk;<br>  <span class="hljs-type">long</span> correction;<br>  <span class="hljs-type">char</span> *snd_brk;<br>  INTERNAL_SIZE_T front_misalign;<br>  INTERNAL_SIZE_T end_misalign;<br>  <span class="hljs-type">char</span> *aligned_brk;<br>  mchunkptr p;<br>  mchunkptr remainder;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;<br>  <span class="hljs-type">size_t</span> pagesize = GLRO (dl_pagesize);<br>  <span class="hljs-type">bool</span> tried_mmap = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span><br>      || ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (mp_.mmap_threshold)<br>	  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))<br>    &#123; <span class="hljs-comment">/* 如果分配区为空或 </span><br><span class="hljs-comment">          用户创建的chunk符合mmap的条件且使用mmap创建的chunk数量没到最大值 </span><br><span class="hljs-comment">          通过mmap创建chunk*/</span><br>      <span class="hljs-type">char</span> *mm;<br>    try_mmap:<br>      <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>        size = ALIGN_UP (nb + SIZE_SZ, pagesize);<br>      <span class="hljs-keyword">else</span><br>        size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);<br>      <span class="hljs-comment">/* 获取用户申请的大小关于 pagesize 对齐后的结果 */</span><br>      tried_mmap = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>        &#123;<br>          mm = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br>          <span class="hljs-comment">/* 使用MMAP函数分配空间 */</span><br>          <span class="hljs-keyword">if</span> (mm != MAP_FAILED)<br>            &#123; <span class="hljs-comment">/* 当空间分配成功时 */</span><br>              <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>                &#123;<br>                  assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                  front_misalign = <span class="hljs-number">0</span>;<br>                  <span class="hljs-comment">/* 检测空间地址是否对齐，因为MALLOC_ALIGNMENT==2*SIZE_SZ</span><br><span class="hljs-comment">                    所以空间必定对齐，如果没有对齐就是程序存在错误 */</span><br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;<br>                <span class="hljs-comment">/* 获取没有对齐的那部分大小 */</span><br>              <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                  correction = MALLOC_ALIGNMENT - front_misalign;<br>                  p = (mchunkptr) (mm + correction);<br>		  set_prev_size (p, correction);<br>                  <span class="hljs-comment">/* 对齐空间并设置头部 */</span><br>                  set_head (p, (size - correction) | IS_MMAPPED);<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  p = (mchunkptr) mm;<br>		  set_prev_size (p, <span class="hljs-number">0</span>);<br>                  set_head (p, size | IS_MMAPPED);<br>                &#125;<br>              <span class="hljs-type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>              <span class="hljs-type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);<br>              <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum;<br>              sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;<br>              <span class="hljs-type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);<br>              <span class="hljs-comment">/* 更新 由mmap分配的空间个数 与 空间大小 */</span><br><br>              check_chunk (av, p); <span class="hljs-comment">/* 检测chunk的地址是否合法 */</span><br>              <span class="hljs-keyword">return</span> chunk2mem (p);<br>            &#125;<br>        &#125;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>      <span class="hljs-comment">/* 因为上面尝试了使用mmap创建chunk，而分配区为空又不能为分配区扩展top chunk</span><br><span class="hljs-comment">          所以没有办法创建chunk了，这时就返回 0 表示分配失败 */</span><br><br>  old_top = av-&gt;top;<br>  old_size = chunksize (old_top);<br>  old_end = (<span class="hljs-type">char</span> *) (chunk_at_offset (old_top, old_size));<br>  brk = snd_brk = (<span class="hljs-type">char</span> *) (MORECORE_FAILURE);<br>  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="hljs-number">0</span>) ||<br>          ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;<br>           prev_inuse (old_top) &amp;&amp;<br>           ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old_end &amp; (pagesize - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>));<br>  assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE));<br>        <span class="hljs-comment">/*先获取 当前分配区正在使用的top chunk的地址，大小，结尾地址， 和 当前内存使用到的空间的尾地址</span><br><span class="hljs-comment">          到达这里只有两种可能</span><br><span class="hljs-comment">            1. 这是第一次申请chunk</span><br><span class="hljs-comment">            2. top chunk的空间不够 用户申请的chunk使用 </span><br><span class="hljs-comment">           因为top chunk在创建时与 pagesize 对齐过了，</span><br><span class="hljs-comment">           如果top chunk的结尾无法对齐pagesize</span><br><span class="hljs-comment">           则表示top chunk被修改过了*/</span><br>  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>    &#123; <span class="hljs-comment">/* 当 当前不是主分配区时 */</span><br>      heap_info *old_heap, *heap;<br>      <span class="hljs-type">size_t</span> old_heap_size;<br>      old_heap = heap_for_ptr (old_top);<br>      old_heap_size = old_heap-&gt;size;<br>      <span class="hljs-comment">/* 先获取当前分配区中关于堆段的信息 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        正常情况下在执行到这个位置可能的原因有:</span><br><span class="hljs-comment">          一、top chunk无法分裂出用户申请的chunk与一个最小chunk</span><br><span class="hljs-comment">          二、初始化分配区</span><br><span class="hljs-comment">      */</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="hljs-number">0</span><br>          &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="hljs-number">0</span>)<br>        &#123; <span class="hljs-comment">/* 尝试扩展heap段，如果扩展成功，则更新top chunk的size 与 当前占用内存空间大小*/</span><br>          av-&gt;system_mem += old_heap-&gt;size - old_heap_size;<br>          set_head (old_top, (((<span class="hljs-type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="hljs-type">char</span> *) old_top)<br>                    | PREV_INUSE);<br><br>        &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="hljs-keyword">sizeof</span> (*heap)), mp_.top_pad)))<br>        &#123;  <span class="hljs-comment">/*   </span><br><span class="hljs-comment">              在初始化分配区，或者扩展heap失败时，尝试创建新的heap段</span><br><span class="hljs-comment">                设置新的top chuk</span><br><span class="hljs-comment">                并释放旧的top chunk*/</span><br>          heap-&gt;ar_ptr = av;<br>          heap-&gt;prev = old_heap;<br>          av-&gt;system_mem += heap-&gt;size;<br>          top (av) = chunk_at_offset (heap, <span class="hljs-keyword">sizeof</span> (*heap));<br>          set_head (top (av), (heap-&gt;size - <span class="hljs-keyword">sizeof</span> (*heap)) | PREV_INUSE);<br>          old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;<br>          set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ), <span class="hljs-number">0</span> | PREV_INUSE);<br>          <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>            &#123;<br>              set_head (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>              set_foot (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ));<br>              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);<br>              _int_free (av, old_top, <span class="hljs-number">1</span>);<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              set_head (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>              set_foot (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ));<br>            &#125;<br>        &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tried_mmap)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          当还没有尝试过使用mmap分配空间</span><br><span class="hljs-comment">          则使用mmap尝试创建chunk</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">goto</span> try_mmap; <br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">/* 主分配区 */</span><br>      size = nb + mp_.top_pad + MINSIZE;<br>      <span class="hljs-keyword">if</span> (contiguous (av)) <br>      <span class="hljs-comment">/* 当程序不允许在同一分配区出现不连续的空间时</span><br><span class="hljs-comment">          设置size为需要增加的字节数量 */</span><br>        size -= old_size;<br>      size = ALIGN_UP (size, pagesize); <span class="hljs-comment">// 对齐size</span><br>      <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>)<br>        &#123; <span class="hljs-comment">// 当size大于0时，尝试使用MORECORE分配空间</span><br>          brk = (<span class="hljs-type">char</span> *) (MORECORE (size));<br>          LIBC_PROBE (memory_sbrk_more, <span class="hljs-number">2</span>, brk, size);<br>        &#125;<br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>        &#123; <span class="hljs-comment">/*</span><br><span class="hljs-comment">               当使用了MORECORE分配空间</span><br><span class="hljs-comment">               且分配成功时</span><br><span class="hljs-comment">          */</span><br>          <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);<br>          <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>            (*hook)();<br>            <span class="hljs-comment">/* 调用__after_morecore_hook中储存的函数地址</span><br><span class="hljs-comment">            */</span><br>        &#125;<br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-keyword">if</span> (contiguous (av))<br>            <span class="hljs-comment">/* 修改size，并对齐 */</span><br>            size = ALIGN_UP (size + old_size, pagesize);<br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (MMAP_AS_MORECORE_SIZE))<br>            <span class="hljs-comment">/* 指定使用mmap从内存中分配chunk的最小size */</span><br>            size = MMAP_AS_MORECORE_SIZE; <br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>            &#123;<br>              <span class="hljs-type">char</span> *mbrk = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br>              <span class="hljs-keyword">if</span> (mbrk != MAP_FAILED)<br>                &#123;<br><br>                  brk = mbrk;<br>                  snd_brk = brk + size;<br>                  set_noncontiguous (av);<br>                  <span class="hljs-comment">// 当mmap分配成功时，更新内存使用信息</span><br>                  <span class="hljs-comment">// 并修改当前分配区的continguous信息</span><br>                  <span class="hljs-comment">// 之后再执行 continguos(av) 时会返回真</span><br>                &#125;<br>            &#125;<br>        &#125;<br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>        &#123;<br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">            当前面的代码分配空间成功时</span><br><span class="hljs-comment">          */</span><br>          <span class="hljs-keyword">if</span> (mp_.sbrk_base == <span class="hljs-number">0</span>)<br>            mp_.sbrk_base = brk;<br>          av-&gt;system_mem += size;<br>          <span class="hljs-keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>            set_head (old_top, (size + old_size) | PREV_INUSE);<br>            <span class="hljs-comment">//  这表示扩建top chunk成功</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)<br>	    malloc_printerr (<span class="hljs-string">&quot;break adjusted to free malloc space&quot;</span>);<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">               当新获取的内存结尾地址，在之前的结尾地址前面，表示出错了</span><br><span class="hljs-comment">              中断程序</span><br><span class="hljs-comment">            */</span><br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              <span class="hljs-comment">/* 这表示新的内存创建成功</span><br><span class="hljs-comment">                且与之前使用的空间不连续 */</span><br>              front_misalign = <span class="hljs-number">0</span>;<br>              end_misalign = <span class="hljs-number">0</span>;<br>              correction = <span class="hljs-number">0</span>;<br>              aligned_brk = brk;<br>              <span class="hljs-keyword">if</span> (contiguous (av))<br>                &#123; <span class="hljs-comment">// 当需要当前分配区中的空间连续时</span><br><br>                  <span class="hljs-keyword">if</span> (old_size)<br>                    <span class="hljs-comment">/* 当 当前没有在初始化分配区时</span><br><span class="hljs-comment">                        修改使用的系统内存大小 </span><br><span class="hljs-comment">                        这里默认空间为连续内存空间*/</span><br>                    av-&gt;system_mem += brk - old_end;<br>                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK; <span class="hljs-comment">// 检测当前空间结尾是否对齐</span><br>                  <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                    &#123; <br>                      correction = MALLOC_ALIGNMENT - front_misalign;<br>                      aligned_brk += correction;<br>                      <span class="hljs-comment">/*</span><br><span class="hljs-comment">                        对齐当前分配区占用内存空间</span><br><span class="hljs-comment">                      */</span><br>                    &#125;<br>                  correction += old_size;<br>                  end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);<br>                  correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;<br>                  assert (correction &gt;= <span class="hljs-number">0</span>);<br>                  snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (correction));<br>                      <span class="hljs-comment">/* 补齐内存空间 防止存在非连续内存空间*/</span><br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                    &#123; <span class="hljs-comment">/* 当分配失败时，停止尝试，仅获取当前使用的内存结尾 */</span><br>                      correction = <span class="hljs-number">0</span>;<br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);<br>                      <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>                        (*hook)();<br>                        <span class="hljs-comment">// 进行分配成功后的处理，一般hook==NULL</span><br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  <span class="hljs-comment">/* 仅检测内存空间是否对齐 */</span><br>                  <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>                    assert (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;<br>                      <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                        &#123;<br>                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;<br>                        &#125;<br>                    &#125;<br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                    &#123;<br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">if</span> (snd_brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                &#123;<br>                  <span class="hljs-comment">/* 当获取内存结束空间地址成功时 </span><br><span class="hljs-comment">                      设置新的heap与新的top chunk</span><br><span class="hljs-comment">                      并释放老的top chunk</span><br><span class="hljs-comment">                  */</span><br>                  av-&gt;top = (mchunkptr) aligned_brk;<br>                  set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);<br>                  av-&gt;system_mem += correction;<br>                  <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)<br>                    &#123;<br>                      old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;<br>                      set_head (old_top, old_size | PREV_INUSE);<br>		      set_head (chunk_at_offset (old_top, old_size),<br>				(<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>		      set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ),<br>				(<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                      <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>                        &#123;<br>                          _int_free (av, old_top, <span class="hljs-number">1</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) av-&gt;system_mem &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (av-&gt;max_system_mem))<br>    av-&gt;max_system_mem = av-&gt;system_mem;<br>   <span class="hljs-comment">// 更新当前最大使用到的系统内存大小</span><br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    先检测当前分配区是否合法，然后将用户需要的chunk创建好，并返回给用户</span><br><span class="hljs-comment">  */</span> <br>  check_malloc_state (av);<br>  p = av-&gt;top;<br>  size = chunksize (p);<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>    &#123;<br>      remainder_size = size - nb;<br>      remainder = chunk_at_offset (p, nb);<br>      av-&gt;top = remainder;<br>      set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>      set_head (remainder, remainder_size | PREV_INUSE);<br>      check_malloced_chunk (av, p, nb);<br>      <span class="hljs-keyword">return</span> chunk2mem (p);<br>    &#125;<br>  __set_errno (ENOMEM);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="释放">释放</h2>
<h3 id="libc-free">__libc_free</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <br>  <br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 检测__free_hook中是否储存了函数地址，</span><br>          <span class="hljs-comment">// 当存在时执行函数，将指向的函数作为释放free函数执行</span><br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)   <span class="hljs-comment">// 防止释放空指针</span><br>    <span class="hljs-keyword">return</span>; <br><br>  p = mem2chunk (mem);<br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <br>    &#123;<br>      <span class="hljs-comment">// 当chunk由mmap分配时</span><br>      <span class="hljs-comment">// 设置mmap的各项参数，然后执行munmap，释放chunk</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold<br>          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX<br>	  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      <br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  MAYBE_INIT_TCACHE (); <br>  <span class="hljs-comment">/* 当tcache bins没有初始化时，</span><br><span class="hljs-comment">      对tcache bins进行初始化操作</span><br><span class="hljs-comment">        也就是从堆空间中获取一段空间，用于tcache bins*/</span><br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">      #define  TCACHE_MAX_BITS 64</span><br><span class="hljs-comment">      typedef struct tcache_perthread_struct</span><br><span class="hljs-comment">      &#123;</span><br><span class="hljs-comment">        uint16_t counts[TCACHE_MAX_BINS];</span><br><span class="hljs-comment">        tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="hljs-comment">      &#125; tcache_perthread_struct;</span><br><span class="hljs-comment">      那么tcache bins占用的空间大小就是 640==0x280</span><br><span class="hljs-comment">      那么tcache bins所在chunk占用的空间就是0x290,位于heap段开头</span><br><span class="hljs-comment">  */</span><br><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">/* 获取chunk所在分配区，调用_int_free函数释放p */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="int-free">_int_free</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;<br>  mfastbinptr *fb;<br>  mchunkptr nextchunk;<br>  INTERNAL_SIZE_T nextsize;<br>  <span class="hljs-type">int</span> nextinuse;<br>  INTERNAL_SIZE_T prevsize;<br>  mchunkptr bck;<br>  mchunkptr fwd;<br>  size = chunksize (p);<br><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) p &gt; (<span class="hljs-type">uintptr_t</span>) -size, <span class="hljs-number">0</span>)<br>      || __builtin_expect (misaligned_chunk (p), <span class="hljs-number">0</span>))<br>    malloc_printerr (<span class="hljs-string">&quot;free(): invalid pointer&quot;</span>) ;<br>    <span class="hljs-comment">//检测chunk的地址是否合法</span><br><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))<br>    malloc_printerr (<span class="hljs-string">&quot;free(): invalid size&quot;</span>);<br>    <span class="hljs-comment">//检测chunk的size是否合法</span><br>  check_inuse_chunk(av, p);<br>    <span class="hljs-comment">/* 检测下一个chunk的inuse位是否为 1</span><br><span class="hljs-comment">        若不为1，则表示当前chunk，在之前已经被释放过了，</span><br><span class="hljs-comment">        这次释放属于程序错误</span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-comment">// 当程序开启了tcache bin时</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      先获取chunk size对应的tcache bin</span><br><span class="hljs-comment">      然后检测对应的tcache bin是否存满 默认每个tcache bin可以储存7个chunk</span><br><span class="hljs-comment">      当没有存满时，直接将当前chunk放入对应的tcache bin中</span><br><span class="hljs-comment">      并结束释放</span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-type">size_t</span> tc_idx = csize2tidx (size);<br>    <span class="hljs-keyword">if</span> (tcache != <span class="hljs-literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>      &#123;<br>	<br>	tcache_entry *e = (tcache_entry *) chunk2mem (p);<br>	<br>	<span class="hljs-keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))<br>	  &#123;<br>	<br>	    tcache_entry *tmp;<br>	    LIBC_PROBE (memory_tcache_double_free, <span class="hljs-number">2</span>, e, tc_idx);<br>	    <span class="hljs-keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];<br>		 tmp;<br>		 tmp = tmp-&gt;next)<br>	      <span class="hljs-keyword">if</span> (tmp == e)<br>		malloc_printerr (<span class="hljs-string">&quot;free(): double free detected in tcache 2&quot;</span>);<br><br>	<br>	  &#125;<br>	<span class="hljs-keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>	  &#123;<br>	<br>	    tcache_put (p, tc_idx);<br>	    <span class="hljs-keyword">return</span>;<br>	  &#125;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(get_max_fast ())<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TRIM_FASTBINS</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      ) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          当chunk的size符合fast bin的条件</span><br><span class="hljs-comment">          且当前chunk不为top chunk</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))<br>			  &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>	|| __builtin_expect (chunksize (chunk_at_offset (p, size))<br>			     &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      &#123;<br>         <span class="hljs-comment">// 检测下一个chunk是否合法</span><br>         <span class="hljs-comment">// 用来判断当前heap段是否为人为伪造的</span><br>	<span class="hljs-type">bool</span> fail = <span class="hljs-literal">true</span>;<br>	<br>	<span class="hljs-keyword">if</span> (!have_lock)<br>	  &#123;<br>	    <span class="hljs-comment">/* 当程序不存在锁时</span><br><span class="hljs-comment">          检测可能存在问题，获取程序锁，再次检测下一个chunk是否合法</span><br><span class="hljs-comment">      */</span><br>	    __libc_lock_lock (av-&gt;mutex);<br>	    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ<br>		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);<br>	    __libc_lock_unlock (av-&gt;mutex);<br>	  &#125;<br>	<span class="hljs-keyword">if</span> (fail)<br>	  malloc_printerr (<span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>);<br>      &#125;<br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br>    <span class="hljs-comment">// 设置chunk的数据段</span><br><br>    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 检测fast bin是否合法</span><br>    <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<br>    fb = &amp;fastbin (av, idx);<br>    <span class="hljs-comment">// 尝试将chunk放入fast bins中</span><br>    mchunkptr old = *fb, old2;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      old为当前fast bin中第一个成员</span><br><span class="hljs-comment">      fast bin中获取chunk的顺序为 先入后出，后入先出</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>      &#123;<br>	   <span class="hljs-comment">// 当仅有一个线程时，直接将当前chunk放入fast bin中</span><br>	<span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>	  malloc_printerr (<span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>);<br><br>	p-&gt;fd = old;<br>	*fb = p;<br>      &#125;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">do</span><br>	&#123;    <span class="hljs-comment">// 当存在多线程时，通过循环获取当前线程的fast bin</span><br>      <span class="hljs-comment">// 并将当前chunk放入当前线程的fast bin中</span><br>	<br>	  <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>      <span class="hljs-comment">/* 检测fast bin的开头是否为当前chunk，如果是则中断程序 */</span><br>	    malloc_printerr (<span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>);<br>	  p-&gt;fd = old2 = old;<br>	&#125;<br>      <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))<br>	     != old2);<br><br>    <br>    <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span><br>	&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="hljs-number">0</span>))<br>      <span class="hljs-comment">//检测当前线程的fast bin是否被修改</span><br>      malloc_printerr (<span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>); <br><br>  &#125;<br><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>    <span class="hljs-comment">// 当chunk不是由mmap分配的时</span><br><br>    <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>      have_lock = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!have_lock)<br>      __libc_lock_lock (av-&gt;mutex);<br>    nextchunk = chunk_at_offset(p, size);<br><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely (p == av-&gt;top))<br>      malloc_printerr (<span class="hljs-string">&quot;double free or corruption (top)&quot;</span>);<br>      <span class="hljs-comment">//禁止释放当前在使用的top chunk</span><br><br>    <span class="hljs-keyword">if</span> (__builtin_expect (contiguous (av)<br>			  &amp;&amp; (<span class="hljs-type">char</span> *) nextchunk<br>			  &gt;= ((<span class="hljs-type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="hljs-number">0</span>))<br>	malloc_printerr (<span class="hljs-string">&quot;double free or corruption (out)&quot;</span>);<br>      <span class="hljs-comment">/* 检测下一个chunk的地址是否合法</span><br><span class="hljs-comment">          在程序指定需要连续的空间的情况下，</span><br><span class="hljs-comment">          下一个chunk的地址必须要在heap段中</span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<br>      malloc_printerr (<span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>);<br>      <span class="hljs-comment">/* 检测下一个chunk的inuse位是否为0</span><br><span class="hljs-comment">        为0表示当前chunk是被释放过的</span><br><span class="hljs-comment">      */</span><br>    nextsize = chunksize(nextchunk);<br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>	|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      malloc_printerr (<span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>);<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">          判断下一个chunk的size是否合法</span><br><span class="hljs-comment">      */</span><br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br>      <span class="hljs-comment">// 设置当前chunk中的数据</span><br><br>    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">        如果当前chunk的inuse位为0，则表示前一个chunk是被释放过的</span><br><span class="hljs-comment">        可以进行合并操作</span><br><span class="hljs-comment">     */</span><br>      prevsize = prev_size (p);<br>      size += prevsize;<br>      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          如果前一个chunk被释放过，</span><br><span class="hljs-comment">          那么当前chunk的prev_size段储存的就是前一个chunk的size</span><br><span class="hljs-comment">          如果条件不成立，则表示程序出现了问题</span><br><span class="hljs-comment">        */</span><br>        malloc_printerr (<span class="hljs-string">&quot;  while consolidating&quot;</span>);<br>      unlink_chunk (av, p);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br>        <span class="hljs-comment">// 如果下一个chunk不是topchunk，则获取下一个chunk后一个chunk的inuse位</span><br>      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>	unlink_chunk (av, nextchunk);<br>    <span class="hljs-comment">//如果下一个chunk的后一个chunk的inuse位为0，则将当前chunk与下一个chunk合并</span><br>	size += nextsize;<br>      <br>      &#125; <span class="hljs-keyword">else</span><br>	clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br>      <span class="hljs-comment">// 如果没到到当前chunk与下一个chunk合并的条件，则设置下一个chunk的inuse位为0</span><br><br>      bck = unsorted_chunks(av); <br>      fwd = bck-&gt;fd;<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>	malloc_printerr (<span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>);<br>      p-&gt;fd = fwd;<br>      p-&gt;bk = bck;<br>      <span class="hljs-comment">// 先检测unsorted bin的结构是否错误</span><br>      <span class="hljs-comment">// 然后获取unsorted bin的开头和结尾</span><br>      <span class="hljs-keyword">if</span> (!in_smallbin_range(size))<br>	&#123;<br>	  p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>	  p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      large bin 中chunk的结构为</span><br><span class="hljs-comment">       prev_size   size</span><br><span class="hljs-comment">       fd          bk</span><br><span class="hljs-comment">       fd_nextsize bk_nextsize</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      其他bin中chunk的结构为</span><br><span class="hljs-comment">       prev_size  size</span><br><span class="hljs-comment">       fd         bk</span><br><span class="hljs-comment">    */</span><br>	&#125;<br>      bck-&gt;fd = p;<br>      fwd-&gt;bk = p;<br>      set_head(p, size | PREV_INUSE);<br>      set_foot(p, size);<br>      check_free_chunk(av, p);<br>      <span class="hljs-comment">// 设置合并后的chunk的头，并检测合并后的chunk是否合法</span><br>    &#125;<br><br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//因为当前chunk的下一个chunk为top chunk</span><br>      <span class="hljs-comment">//所以 直接将当前chunk与top chunk合并</span><br>      <span class="hljs-comment">//设置新的top chunk头，并检测新的top chunk是否合法</span><br>      size += nextsize;<br>      set_head(p, size | PREV_INUSE);<br>      av-&gt;top = p;<br>      check_chunk(av, p);<br><br>    &#125;<br>    <span class="hljs-comment">// #define FASTBIN_CONSOLIDATION_THRESHOLD 65536</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>      <span class="hljs-keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))<br>	malloc_consolidate(av);<br>      <span class="hljs-comment">// 当是否chunk的大小 符合合并 fast bin中chunk的条件时</span><br>      <span class="hljs-comment">// 将fast bin中可以合并的chunk，合并，防止空间碎片过多</span><br>	<br>	<br>      <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>	<span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(chunksize(av-&gt;top)) &gt;=<br>	    (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(mp_.trim_threshold))<br>	  systrim(mp_.top_pad, av);<br>      <span class="hljs-comment">// 当当前处于主分配区时</span><br>      <span class="hljs-comment">// 如果top chunk空间很大，就删减top chunk的空间</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>	<br>	<span class="hljs-comment">// 检测当前分配区空间是否过大</span><br>	heap_info *heap = heap_for_ptr(top(av));<br>	assert(heap-&gt;ar_ptr == av);<br>	heap_trim(heap, mp_.top_pad);<br><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!have_lock)<br>      __libc_lock_unlock (av-&gt;mutex);<br>      <span class="hljs-comment">// 释放锁</span><br>  &#125;<br><br>  <span class="hljs-keyword">else</span> &#123;<br>    munmap_chunk (p);<br>    <span class="hljs-comment">// 释放mmap分配的chunk</span><br>  &#125;<br>&#125;  <br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/heap/" class="category-chain-item">heap</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/ctf/">#ctf</a>
      
        <a href="/tags/pwn/">#pwn</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>堆基础</div>
      <div>https://rot-will.github.io/page/heap/堆基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>rot_will</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月22日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年10月15日</div>
        </div>
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
              <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                <i class="iconfont icon-nc"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
              <span class="hint--top hint--rounded" aria-label="ND - 禁止演绎">
                <i class="iconfont icon-nd"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/page/wp/2021%E9%87%91%E7%A0%96-pwn/" title="2021金砖-pwn">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2021金砖-pwn</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/page/heap/%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E4%B8%80/" title="攻击方法一">
                        <span class="hidden-mobile">攻击方法一</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments">
    
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"rot-will/rot-will.github.io","repo-id":"R_kgDOHgxmbg","category":"Announcements","category-id":"DIC_kwDOHgxmbs4CPuLX","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
    <script src="/lib/page-time.js"></script>
  
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/custom.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
